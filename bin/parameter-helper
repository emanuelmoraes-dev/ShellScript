#!/usr/bin/env bash

# parameter-helper@2.0.2
#
# Utilitário cujo objetivo é receber um conjunto de parâmetros
# nomeados e separar os valores de seus parâmetros.
#
# Variáveis Exportadas:
#     Ao usar este script com \"source\" APENAS as seguintes funções
#     serão definas em escopo globais. Outras Variáveis globais apenas
#     são criadas pelos parâmetros --create-global-args e
#     --create-global-exists
#
#     *   shut_parameterHelper_module:
#             Função principal que envolve todo o programa
#     *   shut_util_array:
#             Cria um array de uma string por meio de um separador
#
#             Parâmetros:
#                 0: Nome do array global com o resultado
#                 1: Separador
#                 2: String a ser convertida em array
#
#             shut_util_array "<array_name>" "<separador>" <string>
#     *   shut_util_join:
#             Exibe na saída padrão uma string de um array unido
#             por meio de um separador
#
#             shut_util_join "<sep>" "${<array>[@]}"
#     *   shut_util_contains:
#             Verifica se uma string está dentro de um array. Se
#             a string estiver no array, finaliza-se a função
#             corretamente. Caso contrário, a função é encerrada
#             com erro
#
#             shut_util_contains "<string>" "${<array>[@]}"
#     *   shut_util_findex:
#             Retorna na saída padrão o index da primeira
#             ocorrência de uma determinada string em um
#             array. Se não existir, ecoa-se -1
#
#             shut_util_findex "<string>" "${array[@]}"
#     *   shut_util_is_letter:
#             Verifica se o caracter é uma letra. Se for
#             uma letra a função é encerrada com sucesso.
#             Caso contrário é encerrada com erro.
#     *   shut_util_adapter_to_variable_name:
#             Ecoa na saída padrão uma string substituindo todos
#             os caracteres da string que não são letras por
#             underline
#
#             Parâmetro: String a ter os caracteres convertidos
#     *   shut_util_remove_begin_underlines:
#             Remove os underlines iniciais de uma string
#
# Parâmetros:
#     --help: Mostra todas as opções. Opcional"
#     --version: Mostra a versão atual deste script. Opcional
#     --index: Posição do parâmetro na qual será retornado seus
#         valores. Valor padrão: 0
#     --out: Exibe os valores do parâmetro da posição --index na
#         saída padrão. Opcional
#     --exists: Lança erro se o parâmetro de --index não foi
#         passado pelo usuário. Encerra a aplicação com sucesso
#         caso o parâmetro foi passado. Opcional
#     --sep: Separador utilizado pela opção --create-array-args
#         para criar strings com os vários valores passados pelo
#         usuário separados por este separador. Tal separador pode
#         ser uma string de vários caracteres. Se esta opção for
#         passada mas não houver valor associado, o valor assumido
#         é uma string vazia. Aconselha-se que o valor de --sep seja
#         qualquer valor não usado em parâmetros. Caso isso seja um
#         grande incoveniente, utilize as variáveis globais criadas
#         com as opções --create-global-args, pois tais variáveis não
#         usam este separador. Valor padrão: $'\n'
#     --is-param: String na qual todos os parâmetros nomeados devem
#         começar Se esta opção for passada mas não houver valor
#         associado a ela, o valor assumido é uma string vazia. Este
#         parâmetro deve sempre vir antes do parâmetro --params.
#         Valor padrão: -
#     --params: Nomes dos parâmetros esperados para o usuário passar
#         (ignorando o valor de --is-param, que por padrão é '-').
#         Obrigatório
#     --flag-params: Nomes dos parâmetros presentes em --params que
#         não esperam nenhum valor. Um parâmetro marcado nesta opção
#         pode ser inserido no meio dos valores de um outro parâmetro.
#         Opcional
#     --create-global-args: Cria arrays globais. Cada array representa
#         um parâmetro diferente. Cada posição de um array é um valor
#         diferente passado pelo usuário. O nome de cada array é o
#         mesmo nome de cada parâmetro, substituindo (por padrão)
#         qualquer caracter que não for uma letra por underline. Se
#         --create-global-args não for informado, esses arrays globais
#         não serão criados. Se não for desejado essas variáveis estarem
#         em escopo global, basta declará-las com o comando "local" do bash
#         antes deste script ser chamado. Opcional
#     --create-global-exists: Cria variáveis globais. Cada variável
#         representa um parâmetro diferente. Cada variável possui 1 ou
#         0. Se o parâmetro foi informado pelo usuário a variável terá 1.
#         Caso contrário, terá 0. O nome de cada variável é o mesmo nome
#         de cada parâmetro, substituindo qualquer caracter que não for
#         uma letra por underline e com o sufixo "_exists". Se
#         --create-global-exists não for informado, essas variáveis
#         globais não serão criadas. Se não for desejado essas variáveis
#         estarem em escopo global, basta declará-las com o comando "local"
#         do bash antes deste script ser chamado. Opcional
#     --uremove: Flag responsável por remover as underlines iniciais das
#         variáveis globais criadas pelos parâmetros --create-global-args e
#         --create-global-exists. Opcional
#     --create-array-args: Nome do array global que conterá os valores de
#         cada parâmetro declarado em --params. Cada posição do array
#         refere-se a um parâmetro na mesma posição que ele foi declarado
#         em --params. Nesta posição encontra-se uma string com todos os
#         valores referentes a esse parâmetro separadas pela string definida
#         por --sep. Se --create-array-args não for informado, o array não é
#         criado. Se --create-arrays-args existir mas não houver valor para
#         ele, o nome do array global será definido como
#         "shut_parameterHelper_args". Opcional
#     --create-array-exists: Nome do array global para informar se cada
#         parâmetro de cada posição foi infomado pelo usuário
#         (0 - não, 1 - sim). Se o --create-array-exists existir mas não
#         houver valor para ele, o nome do array será
#         "shut_parameterHelper_exists". Opcional
#     --no-strict: Impede o lançamento de erro por parâmetro
#         desconhecido. Opcional
#     @@: Informa que os argumentos começarão a ser analizados.
#         Obrigatório
#
# Exemplo 1 (Forma de uso recomendada para a maioria das situações):
#
#     source parameter-helper --create-global-args --create-global-exists --params -v1 -nomes idades @@ -idades 18 20
#
#     echo "${__v1[@]}" # Ecoa array vazio do parâmetro --v1
#
#     if [ "$__nomes_exists" = 1 ]; then # Se o parâmetro --nomes foi passado
#         echo "${__nomes[@]}" # Este código não seria executado
#     fi
#
#     if [ "$_idades_exists" = 1 ]; then # Se o parâmetro -idades foi passado
#         echo "${_idades[@]}" # Ecoa array com as idades '18' e '20'
#     fi
#
# Exemplo 2:
#
#     source parameter-helper --uremove --create-global-args --create-global-exists --params -v1 -nomes idades @@ --nomes Emanuel Pedro
#
#     echo "${v1[@]}" # Ecoa array vazio do parâmetro --v1
#
#     if [ "$nomes_exists" = 1 ]; then # Se o parâmetro --nomes foi passado
#         echo "${nomes[@]}" # Ecoa array com as idades '18' e '20'
#     fi
#
#     if [ "$idades_exists" = 1 ]; then # Se o parâmetro -idades foi passado
#         echo "${idades[@]}" # Este código não seria executado
#     fi
#
# Exemplo 3:
#
#     source parameter-helper --is-param --create-global-args --create-global-exists --params v1 nomes idades @@ idades 18 20
#
#     echo "${v1[@]}" # Ecoa array vazio do parâmetro --v1
#
#     if [ "$nomes_exists" = 1 ]; then # Se o parâmetro --nomes foi passado
#         echo "${nomes[@]}" # Este código não seria executado
#     fi
#
#     if [ "$idades_exists" = 1 ]; then # Se o parâmetro -idades foi passado
#         echo "${idades[@]}" # Ecoa array com as idades '18' e '20'
#     fi
#
# Exemplo 4:
#     source parameter-helper --create-array-args args --params -v1 -nomes idades @@ -idades 20 40 --nomes "" Emanuel Pedro
#
#     shut_util_array nomes $'\n' "${args[1]}"
#
#     # Ecoa array de tamanho 3 com os nomes '' 'Emanuel' e 'Pedro'
#     echo "${nomes[@]}"
#
# Exemplo 5:
#     # Se o parâmetro @v1 foi passado
#     if parameter-helper --exists --is-param @ --index 0 --params v1 nomes idades @@ @v1 1 2 3 @idades 18 20 @nomes Emanuel Pedro; then
#
#         source parameter-helper --no-strict
#
#         shut_util_array v1 $'\n' "$(parameter-helper --out --is-param @ --index 0 --params v1 nomes idades @@ @v1 1 2 3 @idades 18 20 @nomes Emanuel Pedro)"
#
#         echo "${v1[@]}" # Ecoa array com '1', '2' e '3'
#     fi
#
# Exemplo 6:
#     source parameter-helper --sep + --create-array-args args --create-array-exists exists --params -v1 -nomes idades @@ -idades 18 20 --nomes Emanuel Pedro
#
#     shut_util_array v1 + "${args[0]}"
#
#     echo "${v1[@]}" # Ecoa array vazio
#
#     # Se o parâmetro --nomes foi passado
#     if [ "${exists[1]}" = 1 ]; then
#
#         shut_util_array nomes + "${args[1]}"
#
#         # Ecoa array com os nomes 'Emanuel' e 'Pedro'
#         echo "${nomes[@]}"
#     fi
#
# Exemplo 7:
#     source parameter-helper --sep + --create-array-args --create-array-exists --params -v1 -nomes idades @@ -idades 18 20 --nomes Emanuel Pedro
#
#     shut_util_array v1 + "${shut_parameterHelper_args[0]}"
#
#     echo "${v1[@]}" # Ecoa array vazio
#
#     # Se o parâmetro --nomes foi passado
#     if [ "${shut_parameterHelper_exists[1]}" = 1 ]; then
#
#         shut_util_array nomes + "${shut_parameterHelper_args[1]}"
#
#         # Ecoa array com os nomes 'Emanuel' e 'Pedro'
#         echo "${nomes[@]}"
#     fi
#
# Exemplo 8:
#     # Forma de uso NÃO recomendada, pois os argumentos com string vazias
#     # podem ser ignoradas nesta forma de uso caso o --sep seja um
#     # "espaçamento". Além disso, o separador precisa ser definido como um
#     # único caracter. Recomenda-se o uso do utilitário "shut_util_array"
#     # para a criação de arrays sem essas limitações
#
#     IFS=$'\n' # Definindo o separador do sistema para a quebra de linha
#
#     # Array de tamanho 2 com os valores 'Emanuel' e 'Pedro' (usando esta
#     # forma de uso, o segundo valor é ignorado pois é uma string vazia
#     # ao mesmo tempo que o separador é um "espaçamento" (quebra de linha))
#     nomes=($(parameter-helper --out --index 1 --params -v1 -nomes idades @@ -idades 20 40 --nomes Emanuel "" Pedro))
#
#     IFS='+' # Redefinindo o separador do sistema para um não "espaçamento"
#
#     # Array de tamanho 3 com os valores 'Emanuel', '' e 'Pedro' (usando
#     # esta forma de uso, para que o segundo valor seja lido como uma string
#     # vazia, o --sep precisa ser definido como um não "espaçamento")
#     nomes=($(parameter-helper --out --sep + --index 1 --params -v1 -nomes idades @@ -idades 20 40 --nomes Emanuel "" Pedro))
#
#     IFS=' ' # Volta ao separador padrão do sistema
#
# Autor: Emanuel Moraes de Almeida
# Email: emanuelmoraes297@gmail.com
# Github: https://github.com/emanuelmoraes-dev

# Exibe na saída padrão uma string de um array unido por meio
# de um separador
#
# shut_util_join "<sep>" "${<array>[@]}"
function shut_util_join {
    local sep="$1"
    shift
    local rt="$1"
    shift

    for v in "$@"; do
        rt="${rt}${sep}${v}"
    done

    printf "$rt\n"
}

# Verifica se uma string está dentro de um array. Se a string
# estiver no array, finaliza-se a função corretamente. Caso
# contrário, a função é encerrada com erro
#
# shut_util_contains "<string>" "${<array>[@]}"
function shut_util_contains {
    if [ "$#" = 0 ]; then
        return 0
    fi

    local target="$1"
    shift

    local index=0
    for key in "$@"; do
        if [ "$key" = "$target" ]; then
            return 0
        fi

        let index=$index+1
    done

    return 1
}

# Cria um array de uma string por meio de um separador
#
# Parâmetros:
#     0: Nome do array global com o resultado
#     1: Separador
#     2: String a ser convertida em array
#
# shut_util_array "<array_name>" "<separador>" <string>
function shut_util_array {
    local array_name="$1"
    shift

    local sep="$1"
    local len_sep=${#sep}
    local i_last_sep
    let i_last_sep=$len_sep-1
    shift

    local args="$@"
    local len_args=${#args}

    local shut_util_return=()
    local i_return=0

    if [ "$len_args" != "0" ]; then
        shut_util_return[0]=""
    fi

    local ch
    local sub
    local i
    for ((i = 0; i < len_args; i++)); do
        ch="${args:i:1}"
        sub="${args:i:len_sep}"

        if [ -z "$sep" ]; then
            shut_util_return[$i_return]="${ch}"
            let i_return=$i_return+1
        elif [ "$sub" = "$sep" ]; then
            let i_return=$i_return+1
            shut_util_return[$i_return]=""
            let i=$i+$i_last_sep
        else
            shut_util_return[$i_return]="${shut_util_return[i_return]}${ch}"
        fi
    done

    eval $array_name='("${shut_util_return[@]}")'
}

# Ecoa na saída padrão o index da primeira
# ocorrência de uma determinada string em um
# array. Se não existir, ecoa-se -1
#
# shut_util_findex "<string>" "${array[@]}"
function shut_util_findex {
    local target="$1"
    shift

    local index=-1
    local i=0

    while [ "$#" != 0 ]; do
        if [ "$1" = "$target" ]; then
            index=$i
            break
        fi
        let i=$i+1
        shift
    done

    echo $index
}

# Verifica se o caracter é uma letra. Se for
# uma letra a função é encerrada com sucesso.
# Caso contrário é encerrada com erro.
function shut_util_is_letter {
    case "$1" in
        a) return 0;;
        b) return 0;;
        c) return 0;;
        d) return 0;;
        e) return 0;;
        f) return 0;;
        g) return 0;;
        h) return 0;;
        i) return 0;;
        j) return 0;;
        k) return 0;;
        l) return 0;;
        m) return 0;;
        n) return 0;;
        o) return 0;;
        p) return 0;;
        q) return 0;;
        r) return 0;;
        s) return 0;;
        t) return 0;;
        u) return 0;;
        v) return 0;;
        w) return 0;;
        x) return 0;;
        y) return 0;;
        z) return 0;;
        A) return 0;;
        B) return 0;;
        C) return 0;;
        D) return 0;;
        E) return 0;;
        F) return 0;;
        G) return 0;;
        H) return 0;;
        I) return 0;;
        J) return 0;;
        K) return 0;;
        L) return 0;;
        M) return 0;;
        N) return 0;;
        O) return 0;;
        P) return 0;;
        Q) return 0;;
        R) return 0;;
        S) return 0;;
        T) return 0;;
        U) return 0;;
        V) return 0;;
        W) return 0;;
        X) return 0;;
        Y) return 0;;
        Z) return 0;;
        *) return 1;;
    esac
}

# Ecoa na saída padrão uma string substituindo todos
# os caracteres da string que não são letras por
# underline
#
# Parâmetro: String a ter os caracteres  convertidos
function shut_util_adapter_to_variable_name {
    local target="$@"
    local len_target="${#target}"
    local rt
    local ch
    local i
    for ((i = 0; i < len_target; i++)); do
        ch="${target:i:1}"

        if [ "$ch" != "_" ] && ! shut_util_is_letter "$ch"; then
            rt="${rt}_"
        else
            rt="${rt}${ch}"
        fi
    done
    echo "$rt"
}

# Remove os underlines iniciais de uma string
function shut_util_remove_begin_underlines {
    local ok=0
    local target="$@"
    local len_target="${#target}"
    local rt
    local ch
    local i
    for ((i = 0; i < len_target; i++)); do
        ch="${target:i:1}"

        if [ "$ok" = 0 ] && [ "$ch" = "_" ];then
            ch=""
        elif [ "$ok" = 0 ]; then
            ok=1
        fi

        rt="${rt}${ch}"
    done
    echo "$rt"
}

function shut_parameterHelper_module {
    local VERSION=2.0.2

    # CÓDIGOS DE ERRO DO SCRIPT (30-59)
    ## NOT FOUND (3X)
    local ERR_NOT_FOUND_SHUT_UTIL=31
    local ERR_NOT_FOUND_SHUT_UTIL_CONTAINS=32
    local ERR_NOT_FOUND_SHUT_UTIL_ADAPTER_TO_VARIABLE_NAME=33
    local ERR_NOT_FOUND_SHUT_UTIL_REMOVE_BEGIN_UNDERLINES=34
    ## EMPTY (4X)
    local ERR_EMPTY_PARAMS=41
    local ERR_EMPTY_ARGS=42
    ## INVALID (5X)
    local ERR_INVALID_PARAMETER=52
    local ERR_INVALID_ARGUMENTS=53
    local ERR_INVALID_ARGUMENT=54

    function _shut_parameterHelper_helpout {
        echo "parameter-helper@$VERSION"
        echo
        echo "Utilitário cujo objetivo é receber um conjunto de parâmetros"
        echo "nomeados e separar os valores de seus parâmetros"
        echo
        echo "Variáveis Exportadas:"
        echo "    Ao usar este script com \"source\" APENAS as seguintes funções"
        echo "    serão definas em escopo globais. Outras variáveis globais apenas"
        echo "    são criadas pelos parâmetros --create-global-args e"
        echo "    --create-global-exists"
        echo
        echo "    *   shut_parameterHelper_module:"
        echo "            Função principal que envolve todo o programa"
        echo "    *   shut_util_array:"
        echo "            Cria um array de uma string por meio de um separador"
        echo
        echo "            Parâmetros:"
        echo "                0: Nome do array global com o resultado"
        echo "                1: Separador"
        echo "                2: String a ser convertida em array"
        echo
        echo "            shut_util_array \"<array_name>\" \"<separador>\" <string>"
        echo "    *   shut_util_join:"
        echo "            Exibe na saída padrão uma string de um array unido"
        echo "            por meio de um separador"
        echo
        echo "            shut_util_join \"<sep>\" \"\${<array>[@]}\""
        echo "    *   shut_util_contains:"
        echo "            Verifica se uma string está dentro de um array. Se"
        echo "            a string estiver no array, finaliza-se a função"
        echo "            corretamente. Caso contrário, a função é encerrada"
        echo "            com erro"
        echo
        echo "            shut_util_contains \"<string>\" \"\${<array>[@]}\""
        echo "    *   shut_util_findex:"
        echo "            Retorna na saída padrão o index da primeira"
        echo "            ocorrência de uma determinada string em um"
        echo "            array. Se não existir, ecoa-se -1"
        echo
        echo "            shut_util_findex \"<string>\" \"\${array[@]}\""
        echo "    *   shut_util_is_letter:"
        echo "            Verifica se o caracter é uma letra. Se for"
        echo "            uma letra a função é encerrada com sucesso."
        echo "            Caso contrário é encerrada com erro."
        echo "    *   shut_util_adapter_to_variable_name:"
        echo "            Ecoa na saída padrão uma string substituindo todos"
        echo "            os caracteres da string que não são letras por"
        echo "            underline"
        echo
        echo "            Parâmetro: String a ter os caracteres convertidos"
        echo "    *   shut_util_remove_begin_underlines:"
        echo "            Remove os underlines iniciais de uma string"
        echo
        echo "Parâmetros:"
        echo "    --help: Mostra todas as opções. Opcional"
        echo "    --version: Mostra a versão atual deste script. Opcional"
        echo "    --index: Posição do parâmetro na qual será retornado seus"
        echo "        valores. Valor padrão: 0"
        echo "    --out: Exibe os valores do parâmetro da posição --index na"
        echo "        saída padrão. Opcional"
        echo "    --exists: Lança erro se o parâmetro de --index não foi"
        echo "        passado pelo usuário. Encerra a aplicação com sucesso"
        echo "        caso o parâmetro foi passado. Opcional"
        echo "    --sep: Separador utilizado pela opção --create-array-args"
        echo "        para criar strings com os vários valores passados pelo"
        echo "        usuário separados por este separador. Tal separador pode"
        echo "        ser uma string de vários caracteres. Se esta opção for"
        echo "        passada mas não houver valor associado, o valor assumido"
        echo "        é uma string vazia. Aconselha-se que o valor de --sep seja"
        echo "        qualquer valor não usado em parâmetros. Caso isso seja um"
        echo "        grande incoveniente, utilize as variáveis globais criadas"
        echo "        com as opções --create-global-args, pois tais variáveis não"
        echo "        usam este separador. Valor padrão: \$'\n'"
        echo "    --is-param: String na qual todos os parâmetros nomeados devem"
        echo "        começar Se esta opção for passada mas não houver valor"
        echo "        associado a ela, o valor assumido é uma string vazia. Este"
        echo "        parâmetro deve sempre vir antes do parâmetro --params."
        echo "        Valor padrão: -"
        echo "    --params: Nomes dos parâmetros esperados para o usuário passar"
        echo "        (ignorando o valor de --is-param, que por padrão é '-')."
        echo "        Obrigatório"
        echo "    --flag-params: Nomes dos parâmetros presentes em --params que"
        echo "        não esperam nenhum valor. Um parâmetro marcado nesta opção"
        echo "        pode ser inserido no meio dos valores de um outro parâmetro."
        echo "        Opcional"
        echo "    --create-global-args: Cria arrays globais. Cada array representa"
        echo "        um parâmetro diferente. Cada posição de um array é um valor"
        echo "        diferente passado pelo usuário. O nome de cada array é o"
        echo "        mesmo nome de cada parâmetro, substituindo (por padrão)"
        echo "        qualquer caracter que não for uma letra por underline. Se"
        echo "        --create-global-args não for informado, esses arrays globais"
        echo "        não serão criados. Se não for desejado essas variáveis estarem"
        echo "        em escopo global, basta declará-las com o comando \"local\" do bash"
        echo "        antes deste script ser chamado. Opcional"
        echo "    --create-global-exists: Cria variáveis globais. Cada variável"
        echo "        representa um parâmetro diferente. Cada variável possui 1 ou"
        echo "        0. Se o parâmetro foi informado pelo usuário a variável terá 1."
        echo "        Caso contrário, terá 0. O nome de cada variável é o mesmo nome"
        echo "        de cada parâmetro, substituindo qualquer caracter que não for"
        echo "        uma letra por underline e com o sufixo \"_exists\". Se"
        echo "        --create-global-exists não for informado, essas variáveis"
        echo "        globais não serão criadas. Se não for desejado essas variáveis"
        echo "        estarem em escopo global, basta declará-las com o comando \"local\""
        echo "        do bash antes deste script ser chamado. Opcional"
        echo "    --uremove: Flag responsável por remover as underlines iniciais das"
        echo "        variáveis globais criadas pelos parâmetros --create-global-args e"
        echo "        --create-global-exists. Opcional"
        echo "    --create-array-args: Nome do array global que conterá os valores de"
        echo "        cada parâmetro declarado em --params. Cada posição do array"
        echo "        refere-se a um parâmetro na mesma posição que ele foi declarado"
        echo "        em --params. Nesta posição encontra-se uma string com todos os"
        echo "        valores referentes a esse parâmetro separadas pela string definida"
        echo "        por --sep. Se --create-array-args não for informado, o array não é"
        echo "        criado. Se --create-arrays-args existir mas não houver valor para"
        echo "        ele, o nome do array global será definido como"
        echo "        \"shut_parameterHelper_args\". Opcional"
        echo "    --create-array-exists: Nome do array global para informar se cada"
        echo "        parâmetro de cada posição foi infomado pelo usuário"
        echo "        (0 - não, 1 - sim). Se o --create-array-exists existir mas não"
        echo "        houver valor para ele, o nome do array será"
        echo "        \"shut_parameterHelper_exists\". Opcional"
        echo "    --no-strict: Impede o lançamento de erro por parâmetro"
        echo "        desconhecido. Opcional"
        echo "    @@: Informa que os argumentos começarão a ser analizados."
        echo "        Obrigatório"
        echo
        echo "Exemplo 1 (Forma de uso recomendada para a maioria das situações):"
        echo
        echo "    source parameter-helper --create-global-args --create-global-exists --params -v1 -nomes idades @@ -idades 18 20"
        echo
        echo "    echo \"\${__v1[@]}\" # Ecoa array vazio do parâmetro --v1"
        echo
        echo "    if [ \"\$__nomes_exists\" = 1 ]; then # Se o parâmetro --nomes foi passado"
        echo "        echo \"\${__nomes[@]}\" # Este código não seria executado"
        echo "    fi"
        echo
        echo "    if [ \"\$_idades_exists\" = 1 ]; then # Se o parâmetro -idades foi passado"
        echo "        echo \"\${_idades[@]}\" # Ecoa array com as idades '18' e '20'"
        echo "    fi"
        echo
        echo "Exemplo 2:"
        echo
        echo "    source parameter-helper --uremove --create-global-args --create-global-exists --params -v1 -nomes idades @@ --nomes Emanuel Pedro"
        echo
        echo "    echo \"\${v1[@]}\" # Ecoa array vazio do parâmetro --v1"
        echo
        echo "    if [ \"\$nomes_exists\" = 1 ]; then # Se o parâmetro --nomes foi passado"
        echo "        echo \"\${nomes[@]}\" # Ecoa array com as idades '18' e '20'"
        echo "    fi"
        echo
        echo "    if [ \"\$idades_exists\" = 1 ]; then # Se o parâmetro -idades foi passado"
        echo "        echo \"\${idades[@]}\" # Este código não seria executado"
        echo "    fi"
        echo
        echo "Exemplo 3:"
        echo
        echo "    source parameter-helper --is-param --create-global-args --create-global-exists --params v1 nomes idades @@ idades 18 20"
        echo
        echo "    echo \"\${v1[@]}\" # Ecoa array vazio do parâmetro v1"
        echo
        echo "    if [ \"\$nomes_exists\" = 1 ]; then # Se o parâmetro nomes foi passado"
        echo "        echo \"\${nomes[@]}\" # Este código não seria executado"
        echo "    fi"
        echo
        echo "    if [ \"\$idades_exists\" = 1 ]; then # Se o parâmetro idades foi passado"
        echo "        echo \"\${idades[@]}\" # Ecoa array com as idades '18' e '20'"
        echo "    fi"
        echo
        echo "Exemplo 4:"
        echo "    source parameter-helper --create-array-args args --params -v1 -nomes idades @@ -idades 20 40 --nomes \"\" Emanuel Pedro"
        echo
        echo "    shut_util_array nomes \$'\n' \"\${args[1]}\""
        echo
        echo "    # Ecoa array de tamanho 3 com os nomes '' 'Emanuel' e 'Pedro'"
        echo "    echo \"\${nomes[@]}\""
        echo
        echo "Exemplo 5:"
        echo "    # Se o parâmetro @v1 foi passado"
        echo "    if parameter-helper --exists --is-param @ --index 0 --params v1 nomes idades @@ @v1 1 2 3 @idades 18 20 @nomes Emanuel Pedro; then"
        echo
        echo "        source parameter-helper --no-strict"
        echo
        echo "        shut_util_array v1 \$'\n' \"\$(parameter-helper --out --is-param @ --index 0 --params v1 nomes idades @@ @v1 1 2 3 @idades 18 20 @nomes Emanuel Pedro)\""
        echo
        echo "        echo \"\${v1[@]}\" # Ecoa array com '1', '2' e '3'"
        echo "    fi"
        echo
        echo "Exemplo 6:"
        echo "    source parameter-helper --sep + --create-array-args args --create-array-exists exists --params -v1 -nomes idades @@ -idades 18 20 --nomes Emanuel Pedro"
        echo
        echo "    shut_util_array v1 + \"\${args[0]}\""
        echo
        echo "    echo \"\${v1[@]}\" # Ecoa array vazio"
        echo
        echo "    # Se o parâmetro --nomes foi passado"
        echo "    if [ \"\${exists[1]}\" = 1 ]; then"
        echo
        echo "        shut_util_array nomes + \"\${args[1]}\""
        echo
        echo "        # Ecoa Array com os nomes 'Emanuel' e 'Pedro'"
        echo "        echo \"\${nomes[@]}\""
        echo "    fi"
        echo
        echo "Exemplo 7:"
        echo "    source parameter-helper --sep + --create-array-args --create-array-exists --params -v1 -nomes idades @@ -idades 18 20 --nomes Emanuel Pedro"
        echo
        echo "    shut_util_array v1 + \"\${shut_parameterHelper_args[0]}\""
        echo
        echo "    echo \"\${v1[@]}\" # Ecoa array vazio"
        echo
        echo "    # Se o parâmetro --nomes foi passado"
        echo "    if [ \"\${shut_parameterHelper_exists[1]}\" = 1 ]; then"
        echo
        echo "        shut_util_array nomes + \"\${shut_parameterHelper_args[1]}\""
        echo
        echo "        # Ecoa Array com 'Emanuel' e 'Pedro'"
        echo "        echo \"\${nomes[@]}\""
        echo "    fi"
        echo
        echo "Exemplo 8:"
        echo "    # Forma de uso NÃO recomendada, pois os argumentos com string vazias"
        echo "    # podem ser ignoradas nesta forma de uso caso o --sep seja um"
        echo "    # \"espaçamento\". Além disso, o separador precisa ser definido como um"
        echo "    # único caracter. Recomenda-se o uso do utilitário \"shut_util_array\""
        echo "    # para a criação de arrays sem essas limitações"
        echo
        echo "    IFS=$'\n' # Definindo o separador do sistema para a quebra de linha"
        echo
        echo "    # Array de tamanho 2 com os valores 'Emanuel' e 'Pedro' (usando esta"
        echo "    # forma de uso, o segundo valor é ignorado pois é uma string vazia"
        echo "    # ao mesmo tempo que o separador é um \"espaçamento\" (quebra de linha))"
        echo "    nomes=(\$(parameter-helper --out --index 1 --params -v1 -nomes idades @@ -idades 20 40 --nomes Emanuel \"\" Pedro))"
        echo
        echo "    IFS='+' # Redefinindo o separador do sistema para um não \"espaçamento\""
        echo
        echo "    # Array de tamanho 3 com os valores 'Emanuel', '' e 'Pedro' (usando"
        echo "    # esta forma de uso, para que o segundo valor seja lido como uma string"
        echo "    # vazia, o --sep precisa ser definido como um não \"espaçamento\")"
        echo "    nomes=(\$(parameter-helper --out --sep + --index 1 --params -v1 -nomes idades @@ -idades 20 40 --nomes Emanuel \"\" Pedro))"
        echo
        echo "    IFS=' ' # Volta ao separador padrão do sistema"
        echo
        echo "Autor: Emanuel Moraes de Almeida"
        echo "Email: emanuelmoraes297@gmail.com"
        echo "Github: https://github.com/emanuelmoraes-dev"
        echo
    }

    function _shut_parameterHelper_main {
        if [ "$1" = "--help" ]; then # Se --help estiver presente no primeiro argumento
            _shut_parameterHelper_helpout || return $? # Executa função de ajuda na saída padrão
            return 0                                   # Finaliza Script com Sucesso!
        fi

        if [ "$1" = "--version" ]; then # Se --version estiver presente no primeiro argumento
            echo "version: $VERSION"                   # Exibe a versão do script
            return 0                                   # Finaliza Script com Sucesso!
        fi

        local start_args=0                               # Flag para indicar se o parâmetro @@ já foi lido
        local array_args="shut_parameterHelper_args"     # Nome do array criado por --create-array-args
        local array_exists="shut_parameterHelper_exists" # Nome do array criado por --create-array-exists
        local _shut_parameterHelper_args=()              # Array que irá armazenar de forma temporária os valores do array global shut_parameterHelper_args
        local _shut_parameterHelper_exists=()            # Array que irá armazenar de forma temporária os valores do array global shut_parameterHelper_exists
        local present_exists=0                           # Flag para indicar se o parâmetro "--exists" está presente
        local present_create_global_args=0               # Flag para indicar se o parâmetro "--create-global-args" está presente
        local present_create_global_exists=0             # Flag para indicar se o parâmetro "--create-global-exists" está presente
        local present_uremove=0                          # Flag para indicar se o parâmetro "--uremove" está presente
        local present_create_array_args=0                # Flag para indicar se o parâmetro "--create-array-args" está presente
        local present_create_array_exists=0              # Flag para indicar se o parâmetro "--create-array-exists" está presente
        local present_out=0                              # Flag para indicar se o parâmetro "--out" está presente
        local present_no_strict=0                        # Flag para indicar se o parâmetro "--no-strict" está presente
        local param                                      # Parâmetro atual na qual está sendo extraído seus valores
        local empty_param=1                              # Informa se o parâmetro atual ainda não possui valores
        local index="0"                                  # Posição do parâmetro que terá seus valores retornados
        local sep=$'\n'                                  # Separador utilizado para separar os vários elementos de um array de valores passados pelo usuário
        local is_param="-"                               # String na qual todos os parâmetros nomeados devem começar
        local params=()                                  # Parâmetros que serão esperados
        local flag_params=()                             # Parâmetros de --params que não esperam nenhum valor (marcados como flag)
        local used_params=()                             # Parâmetros nomeados usados
        local len_params=0                               # Quantidade de parâmetros já registrados
        local len_flag_params=0                          # Quantidade de parâmetros já marcados como flag
        local i                                          # Index utilizado em loops
        local a                                          # Variável criada no loop principal representando um argumento passado pelo usuário
        local global_variable_name                       # Nome de variável global a ser criada
        local len_global_variable_name                   # Tamanho de array global possivelmente criado
        local local_param                                # Variável temporária para armazenar um parâmetro local

        if [ "$#" = 0 ]; then
            printf >&2 "\e[31;1m\nErro Interno! Argumentos não definidos! Use a opção --help para obter a lista de argumentos!\e[m\n"
            return $ERR_EMPTY_ARGS
        fi

        (
            (shut_util_contains 1> /dev/null 2> /dev/null || return $ERR_NOT_FOUND_SHUT_UTIL_CONTAINS) &&
            (shut_util_adapter_to_variable_name 1> /dev/null 2> /dev/null || return $ERR_NOT_FOUND_SHUT_UTIL_ADAPTER_TO_VARIABLE_NAME) &&
            (shut_util_remove_begin_underlines 1> /dev/null 2> /dev/null || return $ERR_NOT_FOUND_SHUT_UTIL_REMOVE_BEGIN_UNDERLINES)
        ) || (
            err="$?"
            case "$err" in
                $ERR_NOT_FOUND_SHUT_UTIL_CONTAINS)
                    printf >&2 "\e[31;1m\nErro Interno! \"shut_util_contains\" não encontrado!\e[m\n";;
                $ERR_NOT_FOUND_SHUT_UTIL_ADAPTER_TO_VARIABLE_NAME)
                    printf >&2 "\e[31;1m\nErro Interno! \"shut_util_adapter_to_variable_name\" não encontrado!\e[m\n";;
                $ERR_NOT_FOUND_SHUT_UTIL_REMOVE_BEGIN_UNDERLINES)
                    printf >&2 "\e[31;1m\nErro Interno! \"shut_util_remove_begin_underlines\" não encontrado!\e[m\n";;
                *)
                    printf >&2 "\e[31;1m\nErro Interno Inesperado!\e[m\n";;
            esac
            return "$err"
        ) || return "$?"

        for a in "$@"; do # Percorre todos os argumentos passados pelo usuário

            if [ "$start_args" = 0 ] && (
                [ "$a" = "--params" ] ||
                [ "$a" = "--flag-params" ] ||
                [ "$a" = "--index" ] ||
                [ "$a" = "--sep" ] ||
                [ "$a" = "--exists" ] ||
                [ "$a" = "--create-global-args" ] ||
                [ "$a" = "--create-global-exists" ] ||
                [ "$a" = "--uremove" ] ||
                [ "$a" = "--create-array-args" ] ||
                [ "$a" = "--create-array-exists" ] ||
                [ "$a" = "--out" ] ||
                [ "$a" = "--no-strict" ] ||
                [ "$a" = "--is-param" ] ||
                [ "$a" = "@@" ]
            ); then

                param="$a"

                if [ "$a" = "--index" ]; then
                    index=0
                elif [ "$a" = "--sep" ]; then
                    sep=""
                elif [ "$a" = "--exists" ]; then
                    present_exists=1
                elif [ "$a" = "--create-global-args" ]; then
                    present_create_global_args=1
                elif [ "$a" = "--create-global-exists" ]; then
                    present_create_global_exists=1
                elif [ "$a" == "--uremove" ]; then
                    present_uremove=1
                elif [ "$a" = "--create-array-args" ]; then
                    present_create_array_args=1
                elif [ "$a" = "--create-array-exists" ]; then
                    present_create_array_exists=1
                elif [ "$a" = "--out" ]; then
                    present_out=1
                elif [ "$a" = "--no-strict" ]; then
                    present_no_strict=1
                elif [ "$a" = "--is-param" ]; then
                    is_param=""
                elif [ "$a" = "@@" ]; then
                    start_args=1
                    param=""
                fi

            elif [ "$start_args" = 0 ] && [ "$param" != "--params" ] && [ "$param" != "--flag-params" ] && [[ "$a" == --* ]]; then

                printf >&2 "\e[31;1m\nErro Interno! Parâmetro $a inválido!\e[m\n"
                return $ERR_INVALID_PARAMETER # Finaliza Script com erro

            elif [ "$start_args" = 0 ] && [ "$param" = "--index" ]; then

                index="$a"

            elif [ "$start_args" = 0 ] && [ "$param" = "--sep" ]; then

                sep="$a"

            elif [ "$start_args" = 0 ] && [ "$param" = "--create-array-args" ]; then

                array_args="$a"

            elif [ "$start_args" = 0 ] && [ "$param" = "--create-array-exists" ]; then

                array_exists="$a"

            elif [ "$start_args" = 0 ] && [ "$param" = "--is-param" ]; then

                is_param="$a"

            elif [ "$start_args" = 0 ] && [ "$param" = "--params" ]; then # Se 'param' é o parâmetro para setar os parâmetros

                len_params=${#params[@]}                   # Tamanho do array
                params[$len_params]="${is_param}${a}"      # Adiciona no fim do array de 'params' o argumento
                _shut_parameterHelper_args[$len_params]="" # Adiciona no fim do array de '_shut_parameterHelper_args' uma string vazia

            elif [ "$start_args" = 0 ] && [ "$param" = "--flag-params" ]; then # Se 'param' é o parâmetro para setar os parâmetros marcados como flag

                len_flag_params=${#flag_params[@]}                  # Tamanho do array
                flag_params[$len_flag_params]="${is_param}${a}"     # Adiciona no fim do array de 'flag_params' o argumento

            elif [ "$start_args" = 1 ] && (
                (
                    [ "$is_param" ] &&
                    [[ "$a" == $is_param* ]]
                ) || (
                    [ -z "$is_param" ] &&
                    shut_util_contains "$a" "${params[@]}"
                )
            ); then # Se o argumento for o nome de um parâmetro nomeado

                if shut_util_contains "$a" "${flag_params[@]}"; then
                    len_used_params=${#used_params[@]}                                          # Tamanho do array "used_params"
                    used_params[$len_used_params]="$a"                                          # Adiciona no final do array o parâmetro

                    # Limpando possíveis valores já existentes para o parâmetro
                    empty_param=1                                                               # Informa que o parâmetro atual ainda não possui valores
                    i=$(shut_util_findex "$a" "${params[@]}")                                   # Index do parâmetro
                    if [ "$i" != "-1" ]; then                                                   # Se o parâmetro existem em "params"
                        _shut_parameterHelper_args[$i]=""                                           # Limpa os valores deste parâmetro
                        global_variable_name="$(shut_util_adapter_to_variable_name "${params[i]}")" # Nome do array global para os valores deste parâmetro
                        if [ "$present_uremove" = 1 ]; then                                         # Se --uremove foi passado
                            global_variable_name="$(shut_util_remove_begin_underlines "$global_variable_name")" # Remove as underlines do início do nome da variável
                        fi
                        eval len_global_variable_name='${#'$global_variable_name'[@]}'              # Tamanho do array global para os valores deste parâmetro
                        if [ "$len_global_variable_name" != 0 ]; then                               # Se o tamanho do array global para os valores deste parâmetro for zero
                            eval $global_variable_name='()'                                         # O array global para os valores deste parâmetro é inicializado com nenhum valor
                        fi
                    fi
                elif shut_util_contains "$a" "${params[@]}"; then
                    param="$a"                                                                  # 'param' recebe o argumento
                    len_used_params=${#used_params[@]}                                          # Tamanho do array "used_params"
                    used_params[$len_used_params]="$param"                                      # Adiciona no final do array o parâmetro

                    # Limpando possíveis valores já existentes para o parâmetro
                    empty_param=1                                                               # Informa que o parâmetro atual ainda não possui valores
                    i=$(shut_util_findex "$a" "${params[@]}")                                   # Index do parâmetro
                    if [ "$i" != "-1" ]; then                                                   # Se o parâmetro existem em "params"
                        _shut_parameterHelper_args[$i]=""                                           # Limpa os valores deste parâmetro
                        global_variable_name="$(shut_util_adapter_to_variable_name "${params[i]}")" # Nome do array global para os valores deste parâmetro
                        if [ "$present_uremove" = 1 ]; then                                         # Se --uremove foi passado
                            global_variable_name="$(shut_util_remove_begin_underlines "$global_variable_name")" # Remove as underlines do início do nome da variável
                        fi
                        eval len_global_variable_name='${#'$global_variable_name'[@]}'              # Tamanho do array global para os valores deste parâmetro
                        if [ "$len_global_variable_name" != 0 ]; then                               # Se o tamanho do array global para os valores deste parâmetro for zero
                            eval $global_variable_name='()'                                         # O array global para os valores deste parâmetro é inicializado com nenhum valor
                        fi
                    fi
                elif [ "$present_no_strict" = "0" ]; then
                    printf >&2 "\e[31;1m\nErro! Parâmetro $a inválido!\e[m\n"
                    return $ERR_INVALID_PARAMETER # Finaliza Script com erro
                fi

            elif [ "$start_args" = 1 ]; then
                if [ "${#params[@]}" = "0" ]; then # Se 'params' estiver vazio
                    printf >&2 "\e[31;1m\nErro Interno! Contate o desenvolvedor. --params vazios!\e[m\n"
                    return $ERR_EMPTY_PARAMS # Finaliza Script com erro
                fi

                if [ -z "$param" ]; then           # Se nenhum parâmetro nomeado foi passado ainda
                    printf >&2 "\e[31;1m\nErro! Argumento \"$a\" inválido!\e[m\n"
                    return $ERR_INVALID_ARGUMENT # Finaliza Script com erro
                fi

                if [ "$present_exists" = 1 ]; then # Se houver a opção --exists
                    continue                       # Os valores não precisam ser armazenados
                fi

                len_params=${#params[@]}
                for ((i = 0; i < len_params; i++)); do # Percorre a lista de parâmetros
                    local_param="${params[i]}"
                    if [ "$param" = "$local_param" ]; then # Se o 'param' foi encontrado na lista de parâmetros
                        if [ "$empty_param" = 1 ]; then # Se o parâmetro não tiver nenhuma valor
                            _shut_parameterHelper_args[$i]="$a"            # Um novo valor para o parâmetro de posição 'i'
                            empty_param=0                                  # O parâmetro tem valor
                            if [ "$present_create_global_args" = 1 ]; then # Se a flag --create-global-args estiver presente
                                global_variable_name="$(shut_util_adapter_to_variable_name "${params[i]}")" # Nome do array global para os valores deste parâmetro
                                if [ "$present_uremove" = 1 ]; then                                         # Se --uremove foi passado
                                    global_variable_name="$(shut_util_remove_begin_underlines "$global_variable_name")" # Remove as underlines do início do nome da variável
                                fi
                                eval $global_variable_name='("$a")'                                         # O array global para os valores deste parâmetro é inicializado com nenhum valor
                            fi
                        else
                            _shut_parameterHelper_args[$i]="${_shut_parameterHelper_args[$i]}${sep}${a}" # Um novo valor para o parâmetro de posição 'i'
                            if [ "$present_create_global_args" = 1 ]; then                               # Se a flag --create-global-args estiver presente
                                global_variable_name="$(shut_util_adapter_to_variable_name "${params[i]}")" # Nome do array global para os valores deste parâmetro
                                if [ "$present_uremove" = 1 ]; then                                         # Se --uremove foi passado
                                    global_variable_name="$(shut_util_remove_begin_underlines "$global_variable_name")" # Remove as underlines do início do nome da variável
                                fi
                                eval len_global_variable_name='${#'$global_variable_name'[@]}'              # Tamanho do array global para os valores deste parâmetro
                                eval $global_variable_name[$len_global_variable_name]='"$a"'                # O array global para os valores deste parâmetro é inicializado com nenhum valor
                            fi
                        fi

                        break # Finaliza loop
                    fi
                done
            else
                printf >&2 "\e[31;1m\nErro Interno! Argumentos inválidos a partir de \"$a\"!\e[m\n"
                return $ERR_INVALID_ARGUMENTS # Finaliza Script com erro
            fi
        done

        if [ "$present_exists" = 1 ]; then
            shut_util_contains "${params[index]}" "${used_params[@]}"
        else
            if [ "$present_create_array_args" = 1 ]; then
                eval $array_args='("${_shut_parameterHelper_args[@]}")'
            fi

            if [ "$present_create_array_exists" = 1 ]; then
                for ((i = 0; i < len_params; i++)); do
                    if shut_util_contains "${params[i]}" "${used_params[@]}"; then
                        _shut_parameterHelper_exists[$i]=1
                    else
                        _shut_parameterHelper_exists[$i]=0
                    fi
                done

                eval $array_exists='("${_shut_parameterHelper_exists[@]}")'
            fi

            if [ "$present_create_global_exists" = 1 ]; then
                for ((i = 0; i < len_params; i++)); do
                    global_variable_name="$(shut_util_adapter_to_variable_name "${params[i]}")_exists"
                    if [ "$present_uremove" = 1 ]; then # Se --uremove foi passado
                        global_variable_name="$(shut_util_remove_begin_underlines "$global_variable_name")" # Remove as underlines do início do nome da variável
                    fi

                    if shut_util_contains "${params[i]}" "${used_params[@]}"; then
                        eval $global_variable_name=1
                    else
                        eval $global_variable_name=0
                    fi
                done
            fi

            if [ "$present_out" = 1 ]; then
                printf "%s\n" "${_shut_parameterHelper_args[index]}" # Retorna os valores do parâmetro da posição '--index'
            fi
        fi
    }

    _shut_parameterHelper_main "$@" # Executa função principal
}

shut_parameterHelper_module "$@"